<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simulador de Atividade Neural</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
  />
</head>

<body>
  <!-- HERO SECTION -->
  <header>
    <h1>SNNBlaze</h1>
    <p>Simulador eficiente e conciso de atividade neural.</p>
    <a class="btn" href="#features">Funcionalidades</a>
    <a class="btn" href="#demo">Exemplo de Uso</a>
    <a class="btn" href="#ml">Aplicação a Aprendizado de Máquina</a>
    <a class="btn" href="#conclusao">Conclusão</a>
    <a class="btn" href="https://github.com/Eric-OG/snnblaze", target="_blank"><i class="fa-brands fa-github"></i> Repositório</a>
    <a class="btn" href="https://pcs.usp.br/pcspf/wp-content/uploads/sites/8/2025/12/Monografia_PCS3860_COOP_2025_Grupo_C24.pdf", target="_blank"><i class="fa-solid fa-book"></i> Monografia [EN]</a>

  </header>

  <!-- OVERVIEW SECTION -->
  <section id="overview">
    <h2 class="section-title">Visão Geral</h2>
    <p>
      <b>SNNBlaze</b> é um simulador de redes neurais pulsadas, um paradigma de redes neurais que se inspira diretamente no funcionamento biológico do cérebro, que oferece uma modelagem realista e busca emular a eficiência computacional e energética do cérebro humano. Esta ferramente oferece uma implementação concisa e eficaz para a criação e simulação de redes compostas por neurônios do tipo <i>Leaky Integrate-And-Fire</i>, utilizando um modelo de simulação baseado em eventos para maximizar o desempenho.
    </p>
  </section>

  <!-- FEATURES SECTION -->
  <section id="features">
    <h2 class="section-title">Principais Funcionalidades</h2>
    <div class="features-grid">
      <div class="feature-card">
        <h3>Definição de redes neurais</h3>
        <p>O simulador permite instanciar de qualquer rede que possa ser representada por um grafo, incluindo múltiplas populações de neurônio com características distintas.</p>
      </div>
      <div class="feature-card">
        <h3>Simulação eficiente</h3>
        <p>Núcleo de simulação, desenvolvido em C++, oferece um desempenho competitivo, alcançando tempos de simulação comparáveis aos simuladores mais eficientes da área, como Brian 2 e NEST</p>
      </div>
      <div class="feature-card">
        <h3>Interface intuitiva em Python</h3>
        <p>O simulador conta com uma API em Python, que simplifica a configuração e execução de simulações, também permitindo uma integração com outras ferramentas do ecossistema científico, como NumPy e scikit-learn.</p>
      </div>
    </div>
    <p>
      Uma característica chave da implementação é a sua simplicidade: o paradigma de execução baseado em eventos oferece um nível competitivo de desempenho, mas também mantém a implementação do simulador concisa. Isso torna a ferramenta uma boa opção para sistemas embarcados, onde a memória disponível é limitada. 
    </p>
    <p>
      Além disso, é importante ressaltar que a execucão baseada em eventos permite que o simulador realize operações apenas quando um evento ocorre, reduzindo a carga computacional em comparação com um simulador baseado em tempo. A estrutura, assim como as entradas e saídas do simulador estão ilustradas na imagem abaixo:
    </p>
    <div class="demo-media">
      <img src="images/simulator_interfaces.jpg" alt="simulator interfaces" class="demo-image">
    </div>
    <p>
      O <b>SNNBlaze</b> é uma ferramenta de código aberto, disponível no <a href="https://github.com/Eric-OG/snnblaze" target="_blank">GitHub</a>, permitindo que pesquisadores e entusiastas explorem a implementação e contribuam para a sua expansão e aprimoramento.
    </p>
  </section>

  <!-- DEMO SECTION -->
  <section id="demo">
    <h2 class="section-title">Exemplo de Uso</h2>

    <p>Um exemplo de uso da interface em Python para a criação e simulação de uma rede neural simples está ilustrado abaixo.</p>

    <!-- Bloco de código -->
    <h3>Exemplo de código em Python:</h3>
    <pre class="code-block"><code>
    # Initializing a network and monitors
    example_net = pb.NeuralNetwork()
    spike_monitor = pb.SpikeMonitor()
    state_monitor = pb.StateMonitor(reading_interval=0.1e-3)
    spike_monitor.reset_spikes()

    lif_neuron1 = pb.LIFNeuron(tau_m=20e-3, C_m=1, v_rest=-70e-3, v_reset=-70e-3, v_thresh=-50e-3, refractory=2e-3)
    lif_neuron2 = pb.LIFNeuron(tau_m=60e-3, C_m=2, v_rest=-70e-3, v_reset=-70e-3, v_thresh=-50e-3, refractory=2e-3)
    inp_neuron = pb.InputNeuron()

    # Adding neuron populations
    example_net.add_neuron_population(2, lif_neuron1) # index 0,1
    example_net.add_neuron_population(1, lif_neuron2) # index 2
    example_net.add_neuron_population(1, inp_neuron)  # index 3

    # Adding synapses
    synapses = [
        pb.Synapse(3, 0, 10e-3, 10e-3),
        pb.Synapse(0, 1, 15e-3, 10e-3),
        pb.Synapse(1, 2, 20e-3, 10e-3),
        pb.Synapse(2, 0, 10e-3, 10e-3),
    ]
    for syn in synapses:
        example_net.add_synapse(syn)

    # Setting monitors
    example_net.set_spike_monitor(spike_monitor)
    example_net.set_state_monitor(state_monitor)

    # Scheduling 20 spike events for input neuron
    for i in range(50):
        example_net.schedule_spike_event(0.002*i, 3, 20e-3)

    print(f'Network size: {example_net.size()}')

    # Running the network for 200 ms
    example_net.run(0.2)
    </code></pre>
    <p>
      O código corresponde à rede ilustrada na imagem abaixo:
    </p>

    <div class="demo-media">
      <img src="images/website_example.png" alt="example" class="demo-image">
    </div>
    <p>
      Os parâmetros definidos no código buscam se aproximar de valores medidos em neurônios reais. Utilizando essas configurações, o conjunto de imagens a seguir mostra um exemplo de entrada fornecida para a rede, assim como o estado e pulsos gerados pelo neurônio da população 3.
    </p>
    <div class="demo-media">
      <img src="images/ex_input.png" alt="example" class="demo-image">
    </div>
    <div class="demo-media">
      <img src="images/ex_spikes_3.png" alt="example" class="demo-image">
    </div>
    <div class="demo-media">
      <img src="images/ex_state_3.png" alt="example" class="demo-image">
    </div>
  </section>


  <!-- ML SECTION -->
  <section id="ml">
    <h2 class="section-title">Aplicação a Aprendizado de Máquina</h2>
    <p>
    O simulador foi testado para a resolução de problemas de aprendizado de máquina. Isso é possível através da construção de uma <i>liquid state machine</i>. A ideia central dessa estratégia é utilizar um conjunto fixo de neurônios interconectados (o reservatório) para transformar entradas temporais em representações de alta dimensão. As representações obtidas são então usadas para treinar um classificador simples, como nesse caso onde uma regressão logística é utilizada para problemas de classificação. 
    </p>
    <p>
      Dois datasets foram utilizados para avaliar o desempenho do simulador em tarefas de aprendizado de máquina: <i>Spiking Heidelberg Digits</i> e N-MNIST. Ambos são datasets compostos por padrões de pulsos, compatíveis com redes pulsadas.
    </p>
    <p>
    Nesse estudo, um reservatório tridimensional inspirado na topologia de colunas corticais foi utilizado. Esse modelo é instanciado de maneira aleatória, com os parâmetros de geração sendo ajustado para controlar o comportamento global do sistema. Um exemplo de reservatório gerado pode ser visto na imagem abaixo:
    </p>
    
    <div class="demo-media">
      <img src="images/sample_net_555.png" alt="sample network" class="demo-image">
    </div>

    <p>
    Para mais detalhes sobre a arquitetura utilizada e os resultados obtidos, consulte a monografia associada ao projeto.
    </p>

    <h3 class="section-subtitle">Spiking Heidelberg Digits (SHD)</h2>
      <p>
        Este dataset é composto por padrões de pulsos representando dígitos falados (0-9) em inglês e alemão. Cada padrão emula os sinais gerados pela cóclea humana em resposta ao estímulo acústico correspondente. O objetivo dessa tarefa é classificar corretamente os dígitos com base nesses padrões de pulsos.

        A imagem abaixo ilustra um exemplo de padrão de pulsos do dataset SHD para o dígito 1 em inglês:
      </p>
      <div class="demo-media">
        <img src="images/shd_digits_one_sample.png" alt="sample shd" class="demo-image">
      </div>
      <p>
        Ao realizar experimentos utilizando o <b>SNNBlaze</b>, foi possível obter uma exatidão de <b>78,09%</b> nesta tarefa, demonstrando um bom nível de desempenho através do uso do simulador.
      </p>

    <h4 class="section-subtitle">N-MNIST</h2>
      <p>
        Este dataset contém padrões de pulsos que representam dígitos escritos à mão (0-9). Esses padrões são gerados a partir da captura das imagens do dataset MNIST (imagens comuns de dígitos) por meio de uma câmera DVS (<i>Dynamic Vision Sensor</i>), resultando em uma representação baseada em pulsos. Nesta tarefa, a classificação deve ser realizada com base nesses padrões.
      </p>
      <p>
        A imagem abaixo exemplifica um padrão de pulsos do dataset N-MNIST correspondente ao dígito 0 durante 150 ms. Os eventos são organizados em uma grade 2D e também possuem uma polaridade associada:
      </p>
      <div class="demo-media">
        <img src="images/nmnist_digits_zero_sample.png" alt="sample n-mnist" class="demo-image">
      </div>
      <p>
        Ao tratar este problema com uma <i>liquid state machine</i> utilizando o <b>SNNBlaze</b>, foi obtida uma exatidão de <b>95,16%</b>, demonstrando novamente um bom nível de desempenho no tratamento de tarefas de aprendizado de máquina.
      </p>
  </section>

  <!-- ML SECTION -->
  <section id="conclusao">
    <h2 class="section-title">Conclusão</h2>
    <p>
      Foram obtidos resultados relevantes, tanto pelo desenvolvimento de um novo simulador conciso e eficiente quanto pelos resultados obtidos no estudo da implementação de <i>liquid state machines</i> bioinspiradas nesse ambiente, demonstrando bom desempenho em tarefas de classificação.
    </p>
    <p>
      O desempenho do simulador mostrou-se próximo ao estado da arte, demonstrando o potencial da abordagem desenvolvida. Contudo, ainda são possíveis otimizações para aprimorar sua escalabilidade, especialmente para viabilizar simulações eficientes de redes de grande porte. Além disso, seria benéfico expandir suas capacidades, por exemplo, por meio da inclusão de mecanismos de plasticidade sináptica. A inclusão dessas capacidades na modelagem das redes neurais também pode conduzir a melhorias de desempenho no tratamento de problemas de aprendizado de máquina.
    </p>
    <p>
      Em conclusão, o projeto estabelece uma solução eficaz e também uma base sólida para pesquisas futuras, abrindo caminho para o estudo de métodos de simulação mais eficientes e biologicamente plausíveis, fundamentando-se na implementação desenvolvida.
    </p>
    <p>
      Tendo isso em vista, o código do projeto está disponibilizado como código aberto, deixando seu uso e modificação livres para qualquer indivíduo ou organização interessada.
    </p>
  </section>

  <section>
    <h2 class="section-title">Referências</h2>
    <p>
      Uma lista completa das referências utilizadas está disponível na monografia.
    </p>
    <p>
      Para descobrir mais sobre redes neurais pulsadas e <i>liquid state machines</i>, as seguintes referências são úteis:
    </p>
    <p>
      GERSTNER, Wulfram; KISTLER, Werner M. 
      <em>Spiking Neuron Models: Single Neurons, Populations, Plasticity</em>. 
      Cambridge: Cambridge University Press, 2002.
    </p>
    <p>
      YAMAZAKI, Kashu; VO-HO, Viet-Khoa; BULSARA, Darshan; LE, Ngan. 
      Spiking Neural Networks and Their Applications: A Review. 
      <em>Brain Sciences</em>, v. 12, n. 7, p. 863, jun. 2022. 
      DOI: 10.3390/brainsci12070863.
    </p>
    <p>
      MAASS, Wolfgang; NATSCHLÄGER, Thomas; MARKRAM, Henry. 
      Real-Time Computing Without Stable States: A New Framework for Neural Computation Based on Perturbations. 
      <em>Neural Computation</em>, v. 14, n. 11, p. 2531–2560, nov. 2002. 
      DOI: 10.1162/089976602760407955.
    </p>
  </section>

  <!-- FOOTER -->
  <footer>
    © 2025 SNNBlaze – Criado por Eric Oliveira Gomes
  </footer>
</body>
</html>
