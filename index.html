<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simulador de Atividade Neural</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- HERO SECTION -->
  <header>
    <h1>SNNBlaze</h1>
    <p>Simulador eficiente e conciso de atividade neural.</p>
    <a class="btn" href="#features">Conheça mais</a>
  </header>

  <!-- OVERVIEW SECTION -->
  <section id="overview">
    <h2 class="section-title">Visão Geral</h2>
    <p>
      SNNBlaze é um simulador de redes neurais pulsadas, um paradigma de redes neurais que se inspira diretamente no funcionamento biológico do cérebro, que oferece uma modelagem realista e busca emular a eficiência computacional e energética do cérebro humano. Esta ferramente oferece uma implementação concisa e eficaz para a criação e simulação de redes compostas por neurônios do tipo Leaky Integrate-And-Fire, utilizando um modelo de simulação baseado em eventos para maximizar o desempenho.
    </p>
  </section>

  <!-- FEATURES SECTION -->
  <section id="features">
    <h2 class="section-title">Principais Funcionalidades</h2>
    <div class="features-grid">
      <div class="feature-card">
        <h3>Definição de redes neurais</h3>
        <p>O simulador permite instanciar de qualquer rede que possa ser representada por um grafo, incluindo múltiplas populações de neurônio com características distintas.</p>
      </div>
      <div class="feature-card">
        <h3>Simulação eficiente</h3>
        <p>Núcleo de simulação, desenvolvido em C++, oferece um desempenho competitivo, alcançando tempos de simulação comparáveis aos simuladores mais eficientes da área, como Brian 2 e NEST</p>
      </div>
      <div class="feature-card">
        <h3>Interface intuitiva em Python</h3>
        <p>O simulador conta com uma API em Python, que simplifica a configuração e execução de simulações, também permitindo uma integração com outras ferramentas do ecossistema científico, como NumPy e scikit-learn.</p>
      </div>
    </div>
    <p>
      Uma característica chave da implementação é a sua simplicidade: o paradigma de execução baseado em eventos oferece um nível competitivo de desempenho, mas também mantém a implementação do simulador concisa. Isso torna a ferramenta uma boa opção para sistemas embarcados, onde a memória disponível é limitada. 
    </p>
    <p>
      Além disso, é importante ressaltar que a execucão baseada em eventos permite que o simulador realize operações apenas quando um evento ocorre, reduzindo a carga computacional em comparação com um simulador baseado em tempo. A estrutura, assim como as entradas e saídas do simulador estão ilustradas na imagem abaixo:
    </p>
    <div class="demo-media">
      <img src="images/simulator_interfaces.jpg" alt="simulator interfaces" class="demo-image">
    </div>
    <p>
      O SNNBlaze é uma ferramenta de código aberto, disponível no <a href="https://github.com/Eric-OG/snnblaze" target="_blank">GitHub</a>, permitindo que pesquisadores e entusiastas explorem a implementação e contribuam para a sua expansão e aprimoramento.
    </p>
  </section>

  <!-- DEMO SECTION -->
  <section id="demo">
    <h2 class="section-title">Exemplo de Uso</h2>

    <p>Você pode visualizar uma demonstração do simulador ou um exemplo de código de uso abaixo.</p>

    <!-- Bloco de código -->
    <h3>Exemplo de código em Python:</h3>
    <pre class="code-block"><code>
    # Initializing a network and monitors
    example_net = pb.NeuralNetwork()
    spike_monitor = pb.SpikeMonitor()
    state_monitor = pb.StateMonitor(reading_interval=0.1e-3)
    spike_monitor.reset_spikes()

    lif_neuron1 = pb.LIFNeuron(tau_m=20e-3, C_m=1, v_rest=-70e-3, v_reset=-70e-3, v_thresh=-50e-3, refractory=2e-3)
    lif_neuron2 = pb.LIFNeuron(tau_m=60e-3, C_m=2, v_rest=-70e-3, v_reset=-70e-3, v_thresh=-50e-3, refractory=2e-3)
    inp_neuron = pb.InputNeuron()

    # Adding neuron populations
    example_net.add_neuron_population(2, lif_neuron1) # index 0,1
    example_net.add_neuron_population(1, lif_neuron2) # index 2
    example_net.add_neuron_population(1, inp_neuron)  # index 3

    # Adding synapses
    synapses = [
        pb.Synapse(3, 0, 10e-3, 10e-3),
        pb.Synapse(0, 1, 15e-3, 10e-3),
        pb.Synapse(1, 2, 20e-3, 10e-3),
        pb.Synapse(2, 0, 10e-3, 10e-3),
    ]
    for syn in synapses:
        example_net.add_synapse(syn)

    # Setting monitors
    example_net.set_spike_monitor(spike_monitor)
    example_net.set_state_monitor(state_monitor)

    # Scheduling 20 spike events for input neuron
    for i in range(50):
        example_net.schedule_spike_event(0.002*i, 3, 20e-3)

    print(f'Network size: {example_net.size()}')

    # Running the network for 200 ms
    example_net.run(0.2)
    </code></pre>
    <p>
      O código corresponde à rede ilustrada na imagem abaixo:
    </p>

    <div class="demo-media">
      <img src="images/website_example.png" alt="example" class="demo-image">
    </div>
    <p>
      Os parâmetros definidos no código buscam se aproximar de valores medidos em neurônios reais. A imagem abaixo mostra um exemplo de entrada fornecida para a rede, assim como o estado e pulsos gerados pelo neurônio da população 3.
    </p>
    <div class="demo-media">
      <img src="images/ex_input.png" alt="example" class="demo-image">
    </div>
    <div class="demo-media">
      <img src="images/ex_spikes_3.png" alt="example" class="demo-image">
    </div>
    <div class="demo-media">
      <img src="images/ex_state_3.png" alt="example" class="demo-image">
    </div>
  </section>


  <!-- ML SECTION -->
  <section id="ml">
    <h2 class="section-title">Aplicação a Aprendizado de Máquina</h2>
    <p>
    O simulador foi testado para a resolução de problemas de aprendizado de máquina. Isso é possível através da construção de uma "liquid state machine". A ideia central dessa estratégia é utilizar um conjunto fixo de neurônios interconectados (o reservatório) para transformar entradas temporais em representações de alta dimensão. As representações obtidas são então usadas para treinar um classificador simples, como nesse caso onde uma regressão logística é utilizada para problemas de classificação. 
    </p>
    <p>
      Dois datasets foram utilizados para avaliar o desempenho do simulador em tarefas de aprendizado de máquina: Spiking Heidelberg Digits e N-MNIST. Ambos são datasets compostos por padrões de pulsos, compatíveis com redes pulsadas.
    </p>
    <p>
    Nesse estudo, um reservatório tridimensional inspirado na topologia de colunas corticais foi utilizado. Esse modelo é instanciado de maneira aleatória, com os parâmetros de geração sendo ajustado para controlar o comportamento global do sistema. Um exemplo de reservatório gerado pode ser visto na imagem abaixo:
    </p>
    
    <div class="demo-media">
      <img src="images/sample_net_555.png" alt="sample network" class="demo-image">
    </div>

    <p>
    Para mais detalhes sobre a arquitetura utilizada e os resultados obtidos, consulte a monografia associada ao projeto.
    </p>

    <h3 class="section-subtitle">Spiking Heidelberg Digits (SHD)</h2>
      <p>
        Este dataset é composto por padrões de pulsos representando dígitos falados (0-9) em inglês e alemão. Cada padrão emula os sinais gerados pela cóclea humana em resposta ao estímulo acústico correspondente. O objetivo dessa tarefa é classificar corretamente os dígitos com base nesses padrões de pulsos.

        A imagem abaixo ilustra um exemplo de padrão de pulsos do dataset SHD para o dígito 1 em inglês:
      </p>
      <div class="demo-media">
        <img src="images/shd_digits_one_sample.png" alt="sample shd" class="demo-image">
      </div>
      <p>
        Ao realizar experimentos utilizando o <b>SNNBlaze</b>, foi possível obter uma acurácia de <b>77.52%</b> nesta tarefa, demonstrando um bom nível de desempenho através do uso do simulador.
      </p>

    <h4 class="section-subtitle">N-MNIST</h2>
      <p>
        Este dataset contém padrões de pulsos que representam dígitos escritos à mão (0-9). Esses padrões são gerados a partir da captura das imagens do dataset MNIST (imagens comuns de dígitos) por meio de uma câmera DVS (Dynamic Vision Sensor), resultando em uma representação baseada em pulsos. Nesta tarefa, a classificação deve ser realizada com base nesses padrões.
      </p>
      <p>
        A imagem abaixo exemplifica um padrão de pulsos do dataset N-MNIST correspondente ao dígito 0 durante 150 ms. Os eventos são organizados em uma grade 2D e também possuem uma polaridade associada:
      </p>
      <div class="demo-media">
        <img src="images/nmnist_digits_zero_sample.png" alt="sample n-mnist" class="demo-image">
      </div>
      <p>
        Ao tratar este problema com uma <i>liquid state machine</i> utilizando o <b>SNNBlaze</b>, foi obtida uma acurácia de <b>95,16%</b>, demonstrando novamente um bom nível de desempenho no tratamento de tarefas de aprendizado de máquina.
      </p>
  </section>

  <!-- FOOTER -->
  <footer>
    © 2025 SNNBlaze – Criado por Eric Oliveira Gomes
  </footer>
</body>
</html>
